<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gun Shooting Game</title>
  <style>
    :root{--bg:#0b1220;--hud:#e6eef8;--player:#4ee089;--bullet:#ffd166;--enemy:#ff5c5c}
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    .wrap{display:grid;height:100%;place-items:center;background:linear-gradient(180deg,#071021,#0b1220)}
    .game-card{width:360px;background:rgba(255,255,255,0.03);border-radius:12px;padding:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    canvas{display:block;background:linear-gradient(#071021,#061224);border-radius:8px;width:100%;height:auto}
    .hud{display:flex;justify-content:space-between;color:var(--hud);margin-top:8px}
    .controls{margin-top:8px;display:flex;gap:8px}
    button{background:#0f1724;color:var(--hud);border:1px solid rgba(255,255,255,0.05);padding:6px 10px;border-radius:8px;cursor:pointer}
    .hint{font-size:13px;color:#9fb0c8;margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game-card">
      <canvas id="game" width="360" height="640" aria-label="Gun shooting game"></canvas>

      <div class="hud">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
      </div>

      <div class="controls">
        <button id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="restartBtn">Restart</button>
      </div>

      <div class="hint">Controls: ← / → or A / D to move, Space to shoot. On touch: tap left/right to move, tap top to shoot.</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  const W = canvas.width, H = canvas.height;
  let running = false, paused = false;
  let keys = {};

  let player = { x: W/2 - 24, y: H - 70, w:48, h:12, speed:6 };
  let bullets = [];
  let enemies = [];
  let score = 0;
  let lives = 3;
  let spawnTimer = 0;
  let lastTime = 0;

  function reset(){
    player.x = W/2 - player.w/2;
    bullets = [];
    enemies = [];
    score = 0;
    lives = 3;
    spawnTimer = 0;
    updateHud();
  }

  function updateHud(){ scoreEl.textContent = score; livesEl.textContent = lives; }

  function start(){ if(running) return; running = true; paused = false; lastTime = performance.now(); loop(lastTime); }
  function pause(){ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; }
  function restart(){ reset(); running = true; paused = false; lastTime = performance.now(); loop(lastTime); }

  function loop(now){
    if(!running) return;
    const dt = Math.min(40, now - lastTime);
    lastTime = now;
    if(!paused){ update(dt/16); render(); }
    requestAnimationFrame(loop);
  }

  function update(t){
 
    if(keys['ArrowLeft'] || keys['a'] || keys['A']) player.x -= player.speed;
    if(keys['ArrowRight'] || keys['d'] || keys['D']) player.x += player.speed;
    player.x = Math.max(6, Math.min(W - player.w - 6, player.x));

    for(let i=bullets.length-1;i>=0;i--){ bullets[i].y -= bullets[i].speed; if(bullets[i].y < -10) bullets.splice(i,1); }

    spawnTimer += 1;
    const spawnInterval = Math.max(20, 60 - Math.floor(score/20));
    if(spawnTimer > spawnInterval){ spawnTimer = 0; spawnEnemy(); }

    for(let i=enemies.length-1;i>=0;i--){ enemies[i].y += enemies[i].speed; if(enemies[i].y > H + 40){ enemies.splice(i,1); lives--; updateHud(); if(lives<=0) gameOver(); } }

    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      for(let j=enemies.length-1;j>=0;j--){
        const e = enemies[j];
        if(rectIntersect(b.x,b.y,b.w,b.h, e.x,e.y,e.w,e.h)){
          bullets.splice(i,1);
          enemies.splice(j,1);
          score += 10;
          updateHud();
          break;
        }
      }
    }
  }

  function spawnEnemy(){
    const size = 20 + Math.random()*28;
    const x = 6 + Math.random()*(W - size - 12);
    const speed = 1.5 + Math.random()*1.6 + Math.min(3, score/80);
    enemies.push({x, y: -size, w: size, h: size, speed});
  }

  function rectIntersect(x1,y1,w1,h1,x2,y2,w2,h2){
    return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
  }

  function shoot(){
    if(!running || paused) return;

    const now = performance.now();
    const last = shoot.last || 0;
    if(now - last < 120) return;
    shoot.last = now;
    bullets.push({ x: player.x + player.w/2 - 4, y: player.y - 12, w:8, h:12, speed:9 });
  }

  function gameOver(){ running = false; paused = false; setTimeout(()=>{
    const again = confirm('Game Over! Score: ' + score + '\nPlay again?');
    if(again) { reset(); start(); } }, 50);
  }

  function render(){
    ctx.clearRect(0,0,W,H);

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#071021'); g.addColorStop(1,'#061224');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    ctx.fillStyle = '#4ee089';
    roundRect(ctx, player.x, player.y, player.w, player.h, 8, true, false);
    
    ctx.fillRect(player.x + player.w/2 - 6, player.y - 18, 12, 18);

    ctx.fillStyle = '#ffd166';
    bullets.forEach(b => { ctx.beginPath(); ctx.ellipse(b.x + b.w/2, b.y + b.h/2, b.w/2, b.h/2, 0, 0, Math.PI*2); ctx.fill(); });

    ctx.fillStyle = '#ff5c5c';
    enemies.forEach(e => { ctx.beginPath(); ctx.ellipse(e.x + e.w/2, e.y + e.h/2, e.w/2, e.h/2, 0, 0, Math.PI*2); ctx.fill(); });

    ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(6,6,130,28);
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  window.addEventListener('keydown', e => { keys[e.key] = true; if(e.key === ' '){ e.preventDefault(); shoot(); } });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  canvas.addEventListener('touchstart', function(e){
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = (t.clientX - rect.left) * (canvas.width/rect.width);
    const y = (t.clientY - rect.top) * (canvas.height/rect.height);
    if(y < canvas.height * 0.33) { shoot(); }
    else if(x < canvas.width/2) { keys['ArrowLeft'] = true; setTimeout(()=> keys['ArrowLeft'] = false, 150); }
    else { keys['ArrowRight'] = true; setTimeout(()=> keys['ArrowRight'] = false, 150); }
    e.preventDefault();
  }, {passive:false});

  startBtn.addEventListener('click', () => start());
  pauseBtn.addEventListener('click', () => pause());
  restartBtn.addEventListener('click', () => { reset(); start(); });

 
  reset(); render();

})();
</script>
</body>
</html>