<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Gun Shooting Game</title>
  <style>
    :root {
      --hud: #e6eef8;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #08101f, #030712);
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial;
    }
    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: var(--hud);
      font-size: 16px;
      background: rgba(0,0,0,0.4);
      padding: 6px 12px;
      border-radius: 8px;
    }
    .controls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    button {
      background: #0f1724;
      color: var(--hud);
      border: 1px solid rgba(255,255,255,0.2);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="hud">
    Score: <span id="score">0</span> | Lives: <span id="lives">3</span>
  </div>
  <div class="controls">
    <button id="startBtn">Start</button>
    <button id="pauseBtn">Pause</button>
    <button id="restartBtn">Restart</button>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    let scene, camera, renderer;
    let player, bullets = [], enemies = [];
    let running = false, paused = false;
    let score = 0, lives = 3;
    let keys = {};
    let lastShoot = 0;
    let lastSpawn = 0;

    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');

    init();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 8);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(3, 10, 5);
      scene.add(ambient, dirLight);

      // Player
      const playerGeo = new THREE.BoxGeometry(1, 0.4, 1);
      const playerMat = new THREE.MeshStandardMaterial({ color: 0x4ee089 });
      player = new THREE.Mesh(playerGeo, playerMat);
      player.position.set(0, -3, 0);
      scene.add(player);

      window.addEventListener("resize", onResize);
      window.addEventListener("keydown", e => { keys[e.key.toLowerCase()] = true; if(e.key === ' ') shoot(); });
      window.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });

      startBtn.onclick = start;
      pauseBtn.onclick = togglePause;
      restartBtn.onclick = restart;

      render();
    }

    function start() {
      if (running) return;
      running = true;
      paused = false;
      lastSpawn = performance.now();
      animate();
    }

    function restart() {
      bullets.forEach(b => scene.remove(b.mesh));
      enemies.forEach(e => scene.remove(e.mesh));
      bullets = [];
      enemies = [];
      score = 0; lives = 3;
      updateHud();
      running = true; paused = false;
      animate();
    }

    function togglePause() {
      if (!running) return;
      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";
    }

    function updateHud() {
      scoreEl.textContent = score;
      livesEl.textContent = lives;
    }

    function spawnEnemy() {
      const size = 0.6 + Math.random() * 0.5;
      const enemyGeo = new THREE.BoxGeometry(size, size, size);
      const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff5c5c });
      const enemy = new THREE.Mesh(enemyGeo, enemyMat);
      enemy.position.set((Math.random() - 0.5) * 8, 5, 0);
      scene.add(enemy);
      enemies.push({ mesh: enemy, speed: 0.03 + Math.random() * 0.03 });
    }

    function shoot() {
      if (!running || paused) return;
      const now = performance.now();
      if (now - lastShoot < 200) return;
      lastShoot = now;

      const geo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
      const mat = new THREE.MeshStandardMaterial({ color: 0xffd166 });
      const bullet = new THREE.Mesh(geo, mat);
      bullet.rotation.x = Math.PI / 2;
      bullet.position.copy(player.position);
      scene.add(bullet);
      bullets.push({ mesh: bullet, speed: 0.2 });
    }

    function animate() {
      if (!running) return;
      requestAnimationFrame(animate);
      if (paused) return;

      const now = performance.now();

      // Player movement
      if (keys['arrowleft'] || keys['a']) player.position.x -= 0.1;
      if (keys['arrowright'] || keys['d']) player.position.x += 0.1;
      player.position.x = Math.max(-4, Math.min(4, player.position.x));

      // Spawn enemies
      if (now - lastSpawn > Math.max(500, 2000 - score * 10)) {
        spawnEnemy();
        lastSpawn = now;
      }

      // Update bullets
      bullets.forEach((b, i) => {
        b.mesh.position.y += b.speed;
        if (b.mesh.position.y > 6) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
        }
      });

      // Update enemies
      enemies.forEach((e, i) => {
        e.mesh.position.y -= e.speed;
        if (e.mesh.position.y < -4) {
          scene.remove(e.mesh);
          enemies.splice(i, 1);
          lives--;
          updateHud();
          if (lives <= 0) gameOver();
        }
      });

      // Check collisions
      bullets.forEach((b, bi) => {
        enemies.forEach((e, ei) => {
          if (b.mesh.position.distanceTo(e.mesh.position) < 0.6) {
            scene.remove(b.mesh);
            scene.remove(e.mesh);
            bullets.splice(bi, 1);
            enemies.splice(ei, 1);
            score += 10;
            updateHud();
          }
        });
      });

      render();
    }

    function render() {
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function gameOver() {
      running = false;
      alert("Game Over! Score: " + score);
    }
  </script>
</body>
</html>
